/*!
 * pixi-tilemap - v2.1.3
 * Compiled Sun, 18 Oct 2020 17:08:58 UTC
 *
 * pixi-tilemap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *
 * Copyright 2019-2020, Ivan Popelyshev, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.tilemap=this.PIXI.tilemap||{},function(c,_){typeof exports=="object"&&typeof module!="undefined"?_(exports,require("@pixi/display"),require("@pixi/core"),require("@pixi/constants"),require("@pixi/math"),require("@pixi/graphics"),require("@pixi/sprite")):typeof define=="function"&&define.amd?define(["exports","@pixi/display","@pixi/core","@pixi/constants","@pixi/math","@pixi/graphics","@pixi/sprite"],_):(c=typeof globalThis!="undefined"?globalThis:c||self,_(c.pixi_tilemap={},c.PIXI,c.PIXI,c.PIXI,c.PIXI,c.PIXI,c.PIXI))}(this,function(c,_,I,R,T,le,he){"use strict";class k{constructor(e){this.tileAnim=[0,0],this.dontUseTransform=!1,this.renderer=e,this.tileAnim=[0,0]}}const ie=PIXI.CanvasRenderer;ie&&ie.registerPlugin("tilemap",k);const m={maxTextures:16,bufferSize:2048,boundSize:1024,boundCountPerBuffer:1,use32bitIndex:!1,SCALE_MODE:R.SCALE_MODES.LINEAR,DO_CLEAR:!0},M=12;class L extends _.Container{constructor(e,t){super();this.zIndex=0,this.modificationMarker=0,this._$_localBounds=new _.Bounds,this.shadowColor=new Float32Array([0,0,0,.5]),this._globalMat=null,this.pointsBuf=[],this.hasAnim=!1,this.offsetX=0,this.offsetY=0,this.compositeParent=!1,this.tileAnim=null,this.vbId=0,this.vb=null,this.vbBuffer=null,this.vbArray=null,this.vbInts=null,this.initialize(e,t)}initialize(e,t){t?!(t instanceof Array)&&t.baseTexture&&(t=[t]):t=[],this.textures=t,this.zIndex=e}clear(){this.pointsBuf.length=0,this.modificationMarker=0,this._$_localBounds.clear(),this.hasAnim=!1}addFrame(e,t,i,r,s){let a,u=0;if(typeof e=="number")u=e,a=this.textures[u];else{typeof e=="string"?a=I.Texture.from(e):a=e;let h=!1,l=this.textures;for(let f=0;f<l.length;f++)if(l[f].baseTexture===a.baseTexture){u=f,h=!0;break}if(!h)return!1}return this.addRect(u,a.frame.x,a.frame.y,t,i,a.orig.width,a.orig.height,r,s,a.rotate),!0}addRect(e,t,i,r,s,a,u,h=0,l=0,f=0,p=1024,n=1024){let d=this.pointsBuf;return this.hasAnim=this.hasAnim||h>0||l>0,d.push(t),d.push(i),d.push(r),d.push(s),d.push(a),d.push(u),d.push(f),d.push(h|0),d.push(l|0),d.push(e),d.push(p),d.push(n),this._$_localBounds.addFramePad(r,s,r+a,s+u,0,0),this}tileRotate(e){const t=this.pointsBuf;t[t.length-3]=e}tileAnimX(e,t){const i=this.pointsBuf;i[i.length-5]=e,i[i.length-2]=t}tileAnimY(e,t){const i=this.pointsBuf;i[i.length-4]=e,i[i.length-1]=t}renderCanvas(e){if(!e.plugins.tilemap.dontUseTransform){let i=this.worldTransform;e.context.setTransform(i.a,i.b,i.c,i.d,i.tx*e.resolution,i.ty*e.resolution)}this.renderCanvasCore(e)}renderCanvasCore(e){if(this.textures.length===0)return;let t=this.pointsBuf;const i=this.tileAnim||e.plugins.tilemap.tileAnim;e.context.fillStyle="#000000";for(let s=0,a=t.length;s<a;s+=M){let u=t[s],h=t[s+1],l=t[s+2],f=t[s+3],p=t[s+4],n=t[s+5];var r=t[s+6];u+=t[s+7]*i[0],h+=t[s+8]*i[1];let d=t[s+9];d>=0?e.context.drawImage(this.textures[d].baseTexture.getDrawableSource(),u,h,p,n,l,f,p,n):(e.context.globalAlpha=.5,e.context.fillRect(l,f,p,n),e.context.globalAlpha=1)}}destroyVb(){this.vb&&(this.vb.destroy(),this.vb=null)}render(e){let t=e.plugins.tilemap,i=t.getShader();e.batch.setObjectRenderer(t),this._globalMat=i.uniforms.projTransMatrix,e.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform),i.uniforms.shadowColor=this.shadowColor,i.uniforms.animationFrame=this.tileAnim||t.tileAnim,this.renderWebGLCore(e,t)}renderWebGLCore(e,t){let i=this.pointsBuf;if(i.length===0)return;let r=i.length/M,s=t.getShader(),a=this.textures;if(a.length===0)return;t.bindTextures(e,s,a),e.shader.bind(s,!1);let u=this.vb;u||(u=t.createVb(),this.vb=u,this.vbId=u.id,this.vbBuffer=null,this.modificationMarker=0),t.checkIndexBuffer(r,u);const h=m.boundCountPerBuffer;let l=u.getBuffer("aVertexPosition"),f=r*u.vertPerQuad;if(f!==0){if(this.modificationMarker!==f){this.modificationMarker=f;let p=u.stride*f;if(!this.vbBuffer||this.vbBuffer.byteLength<p){let x=u.stride;for(;x<p;)x*=2;this.vbBuffer=new ArrayBuffer(x),this.vbArray=new Float32Array(this.vbBuffer),this.vbInts=new Uint32Array(this.vbBuffer),l.update(this.vbBuffer)}let n=this.vbArray,d=this.vbInts,o=0,C=0,N=this.offsetX,q=this.offsetY,be=-1;for(let x=0;x<i.length;x+=M){let y=.5;this.compositeParent&&(h>1?(C=i[x+9]>>2,N=this.offsetX*(i[x+9]&1),q=this.offsetY*(i[x+9]>>1&1)):(C=i[x+9],N=0,q=0));let z=i[x+2],D=i[x+3],A=i[x+4],w=i[x+5],v=i[x]+N,S=i[x+1]+q,g=i[x+6];const ce=i[x+7],me=i[x+8],pe=i[x+10]||1024,xe=i[x+11]||1024,F=ce+pe*2048,X=me+xe*2048;let $,H,Z,Q,K,J,ee,te;if(g===0)$=v,H=S,Z=v+A,Q=S,K=v+A,J=S+w,ee=v,te=S+w;else{let B=A/2,P=w/2;g%4!=0&&(B=w/2,P=A/2);const E=v+B,O=S+P;g=T.groupD8.add(g,T.groupD8.NW),$=E+B*T.groupD8.uX(g),H=O+P*T.groupD8.uY(g),g=T.groupD8.add(g,2),Z=E+B*T.groupD8.uX(g),Q=O+P*T.groupD8.uY(g),g=T.groupD8.add(g,2),K=E+B*T.groupD8.uX(g),J=O+P*T.groupD8.uY(g),g=T.groupD8.add(g,2),ee=E+B*T.groupD8.uX(g),te=O+P*T.groupD8.uY(g)}n[o++]=z,n[o++]=D,n[o++]=$,n[o++]=H,n[o++]=v+y,n[o++]=S+y,n[o++]=v+A-y,n[o++]=S+w-y,n[o++]=F,n[o++]=X,n[o++]=C,n[o++]=z+A,n[o++]=D,n[o++]=Z,n[o++]=Q,n[o++]=v+y,n[o++]=S+y,n[o++]=v+A-y,n[o++]=S+w-y,n[o++]=F,n[o++]=X,n[o++]=C,n[o++]=z+A,n[o++]=D+w,n[o++]=K,n[o++]=J,n[o++]=v+y,n[o++]=S+y,n[o++]=v+A-y,n[o++]=S+w-y,n[o++]=F,n[o++]=X,n[o++]=C,n[o++]=z,n[o++]=D+w,n[o++]=ee,n[o++]=te,n[o++]=v+y,n[o++]=S+y,n[o++]=v+A-y,n[o++]=S+w-y,n[o++]=F,n[o++]=X,n[o++]=C}l.update(n)}e.geometry.bind(u,s),e.geometry.draw(R.DRAW_MODES.TRIANGLES,r*6,0)}}isModified(e){return!!(this.modificationMarker!==this.pointsBuf.length||e&&this.hasAnim)}clearModify(){this.modificationMarker=this.pointsBuf.length}_calculateBounds(){const{minX:e,minY:t,maxX:i,maxY:r}=this._$_localBounds;this._bounds.addFrame(this.transform,e,t,i,r)}getLocalBounds(e){return this.children.length===0?this._$_localBounds.getRectangle(e):super.getLocalBounds.call(this,e)}destroy(e){super.destroy(e),this.destroyVb()}}class re extends _.Container{constructor(e,t,i){super();this.modificationMarker=0,this.shadowColor=new Float32Array([0,0,0,.5]),this._globalMat=null,this._lastLayer=null,this.tileAnim=null,this.initialize.apply(this,arguments)}initialize(e,t,i){i===!0&&(i=0),this.z=this.zIndex=e,this.texPerChild=i||m.boundCountPerBuffer*m.maxTextures,t&&this.setBitmaps(t)}setBitmaps(e){for(let a=0;a<e.length;a++)if(e[a]&&!e[a].baseTexture)throw new Error("pixi-tilemap cannot use destroyed textures. Probably, you passed resources['myAtlas'].texture in pixi > 5.2.1, it does not exist there.");let t=this.texPerChild,i=this.children.length,r=Math.ceil(e.length/t),s;for(s=0;s<i;s++)this.children[s].textures=e.slice(s*t,(s+1)*t);for(s=i;s<r;s++){let a=new L(this.zIndex,e.slice(s*t,(s+1)*t));a.compositeParent=!0,a.offsetX=m.boundSize,a.offsetY=m.boundSize,this.addChild(a)}}clear(){for(let e=0;e<this.children.length;e++)this.children[e].clear();this.modificationMarker=0}addRect(e,t,i,r,s,a,u,h,l,f,p,n){const d=e/this.texPerChild>>0,o=e%this.texPerChild;return this.children[d]&&this.children[d].textures?(this._lastLayer=this.children[d],this._lastLayer.addRect(o,t,i,r,s,a,u,h,l,f,p,n)):this._lastLayer=null,this}tileRotate(e){return this._lastLayer&&this._lastLayer.tileRotate(e),this}tileAnimX(e,t){return this._lastLayer&&this._lastLayer.tileAnimX(e,t),this}tileAnimY(e,t){return this._lastLayer&&this._lastLayer.tileAnimY(e,t),this}addFrame(e,t,i,r,s,a,u){let h,l=null,f=0,p=this.children;if(this._lastLayer=null,typeof e=="number"){let n=e/this.texPerChild>>0;if(l=p[n],l)f=e%this.texPerChild;else{if(l=p[0],!l)return this;f=0}h=l.textures[f]}else{typeof e=="string"?h=I.Texture.from(e):h=e;for(let n=0;n<p.length;n++){let d=p[n],o=d.textures;for(let C=0;C<o.length;C++)if(o[C].baseTexture===h.baseTexture){l=d,f=C;break}if(l)break}if(!l){for(let n=0;n<p.length;n++){let d=p[n];if(d.textures.length<this.texPerChild){l=d,f=d.textures.length,d.textures.push(h);break}}l||(l=new L(this.zIndex,h),l.compositeParent=!0,l.offsetX=m.boundSize,l.offsetY=m.boundSize,this.addChild(l),f=0)}}return this._lastLayer=l,l.addRect(f,h.frame.x,h.frame.y,t,i,h.orig.width,h.orig.height,r,s,h.rotate,a,u),this}renderCanvas(e){if(!this.visible||this.worldAlpha<=0||!this.renderable)return;if(!e.plugins.tilemap.dontUseTransform){let r=this.worldTransform;e.context.setTransform(r.a,r.b,r.c,r.d,r.tx*e.resolution,r.ty*e.resolution)}let i=this.children;for(let r=0;r<i.length;r++){const s=i[r];s.tileAnim=this.tileAnim,s.renderCanvasCore(e)}}render(e){if(!this.visible||this.worldAlpha<=0||!this.renderable)return;let t=e.plugins.tilemap,i=t.getShader();e.batch.setObjectRenderer(t),this._globalMat=i.uniforms.projTransMatrix,e.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform),i.uniforms.shadowColor=this.shadowColor,i.uniforms.animationFrame=this.tileAnim||t.tileAnim,e.shader.bind(i,!1);let r=this.children;for(let s=0;s<r.length;s++)r[s].renderWebGLCore(e,t)}isModified(e){let t=this.children;if(this.modificationMarker!==t.length)return!0;for(let i=0;i<t.length;i++)if(t[i].isModified(e))return!0;return!1}clearModify(){let e=this.children;this.modificationMarker=e.length;for(let t=0;t<e.length;t++)e[t].clearModify()}}class se extends le.Graphics{constructor(e){super();this.zIndex=e}renderCanvas(e){let t=null;e.plugins.tilemap.dontUseTransform&&(t=this.transform.worldTransform,this.transform.worldTransform=T.Matrix.IDENTITY),e.plugins.graphics.render(this),e.plugins.tilemap.dontUseTransform&&(this.transform.worldTransform=t),e.context.globalAlpha=1}isModified(e){return!1}clearModify(){}}class U extends I.resources.Resource{constructor(e){super(e.bufferSize,e.bufferSize);this.DO_CLEAR=!1,this.boundSize=0,this._clearBuffer=null,this.baseTex=null,this.boundSprites=[],this.dirties=[];const t=this.boundSprites,i=this.dirties;this.boundSize=e.boundSize;for(let r=0;r<e.boundCountPerBuffer;r++){const s=new he.Sprite;s.position.x=e.boundSize*(r&1),s.position.y=e.boundSize*(r>>1),t.push(s),i.push(0)}this.DO_CLEAR=!!e.DO_CLEAR}bind(e){if(this.baseTex)throw new Error("Only one baseTexture is allowed for this resource!");this.baseTex=e,super.bind(e)}setTexture(e,t){const i=this.boundSprites[e];i.texture.baseTexture!==t.baseTexture&&(i.texture=t,this.baseTex.update(),this.dirties[e]=this.baseTex.dirtyId)}upload(e,t,i){const{gl:r}=e,{width:s,height:a}=this;r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.alphaMode===void 0||t.alphaMode===R.ALPHA_MODES.UNPACK),i.dirtyId<0&&(i.width=s,i.height=a,r.texImage2D(t.target,0,t.format,s,a,0,t.format,t.type,null));const u=this.DO_CLEAR;u&&!this._clearBuffer&&(this._clearBuffer=new Uint8Array(m.boundSize*m.boundSize*4));const h=this.boundSprites;for(let l=0;l<h.length;l++){const f=h[l],p=f.texture.baseTexture;if(i.dirtyId>=this.dirties[l])continue;const n=p.resource;!p.valid||!n||!n.source||(u&&(p.width<this.boundSize||p.height<this.boundSize)&&r.texSubImage2D(t.target,0,f.position.x,f.position.y,this.boundSize,this.boundSize,t.format,t.type,this._clearBuffer),r.texSubImage2D(t.target,0,f.position.x,f.position.y,t.format,t.type,n.source))}return!0}}function Y(b,e){let t=[];for(let r=0;r<e;r++)t[r]=r;b.uniforms.uSamplers=t;let i=[];for(let r=0;r<e;r++)i.push(1/m.bufferSize),i.push(1/m.bufferSize);b.uniforms.uSamplerSize=i}function ne(b,e){return e.replace(/%count%/gi,b+"").replace(/%forloop%/gi,ae(b))}function ae(b){let e="";e+=`
`,e+=`
`,e+="if(vTextureId <= -1.0) {",e+=`
	color = shadowColor;`,e+=`
}`;for(let t=0;t<b;t++)e+=`
else `,t<b-1&&(e+="if(textureId == "+t+".0)"),e+=`
{`,e+=`
	color = texture2D(uSamplers[`+t+"], textureCoord * uSamplerSize["+t+"]);",e+=`
}`;return e+=`
`,e+=`
`,e}let ue=`
varying vec2 vTextureCoord;
varying vec4 vFrame;
varying float vTextureId;
uniform vec4 shadowColor;
uniform sampler2D uSamplers[%count%];
uniform vec2 uSamplerSize[%count%];

void main(void){
   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);
   float textureId = floor(vTextureId + 0.5);

   vec4 color;
   %forloop%
   gl_FragColor = color;
}
`,fe=`
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aFrame;
attribute vec2 aAnim;
attribute float aTextureId;

uniform mat3 projTransMatrix;
uniform vec2 animationFrame;

varying vec2 vTextureCoord;
varying float vTextureId;
varying vec4 vFrame;

void main(void){
   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vec2 animCount = floor((aAnim + 0.5) / 2048.0);
   vec2 animFrameOffset = aAnim - animCount * 2048.0;
   vec2 animOffset = animFrameOffset * floor(mod(animationFrame + 0.5, animCount));

   vTextureCoord = aTextureCoord + animOffset;
   vFrame = aFrame + vec4(animOffset, animOffset);
   vTextureId = aTextureId;
}
`;class j extends I.Shader{constructor(e,t,i){super(new I.Program(t,i),{animationFrame:new Float32Array(2),uSamplers:[],uSamplerSize:[],projTransMatrix:new T.Matrix});this.maxTextures=0,this.maxTextures=e,Y(this,this.maxTextures)}}class G extends j{constructor(e){super(e,fe,ne(e,ue));Y(this,this.maxTextures)}}class V extends I.Geometry{constructor(){super();this.vertSize=11,this.vertPerQuad=4,this.stride=this.vertSize*4,this.lastTimeAccess=0;const e=this.buf=new I.Buffer(new Float32Array(2),!0,!1);this.addAttribute("aVertexPosition",e,0,!1,0,this.stride,0).addAttribute("aTextureCoord",e,0,!1,0,this.stride,2*4).addAttribute("aFrame",e,0,!1,0,this.stride,4*4).addAttribute("aAnim",e,0,!1,0,this.stride,8*4).addAttribute("aTextureId",e,0,!1,0,this.stride,10*4)}}class W extends I.ObjectRenderer{constructor(e){super(e);this.sn=-1,this.indexBuffer=null,this.ibLen=0,this.tileAnim=[0,0],this.texLoc=[],this.texResources=[],this.rectShader=new G(m.maxTextures),this.indexBuffer=new I.Buffer(void 0,!0,!0),this.checkIndexBuffer(2e3),this.initBounds()}initBounds(){if(m.boundCountPerBuffer<=1)return;const e=m.maxTextures;for(let t=0;t<e;t++){const i=new U(m),r=new I.BaseTexture(i);r.scaleMode=m.SCALE_MODE,r.wrapMode=R.WRAP_MODES.CLAMP,this.texResources.push(i)}}bindTexturesWithoutRT(e,t,i){let r=t.uniforms.uSamplerSize;this.texLoc.length=0;for(let s=0;s<i.length;s++){const a=i[s];if(!a||!a.valid)return;e.texture.bind(i[s],s),r[s*2]=1/i[s].baseTexture.width,r[s*2+1]=1/i[s].baseTexture.height}t.uniforms.uSamplerSize=r}bindTextures(e,t,i){const r=i.length,s=m.maxTextures;if(r>m.boundCountPerBuffer*s)return;if(m.boundCountPerBuffer<=1){this.bindTexturesWithoutRT(e,t,i);return}let a=0;for(;a<r;a++){const h=i[a];if(!h||!h.valid)continue;this.texResources[a>>2].setTexture(a&3,h)}let u=a+3>>2;for(a=0;a<u;a++)e.texture.bind(this.texResources[a].baseTex,a)}start(){}createVb(){const e=new V;return e.addIndex(this.indexBuffer),e.lastTimeAccess=Date.now(),e}checkIndexBuffer(e,t=null){const i=e*6;if(i<=this.ibLen)return;let r=i;for(;r<i;)r<<=1;this.ibLen=i,this.indexBuffer.update(PIXI.utils.createIndicesForQuads(e,m.use32bitIndex?new Uint32Array(e*6):void 0))}getShader(){return this.rectShader}destroy(){super.destroy(),this.rectShader=null}}I.Renderer.registerPlugin("tilemap",W);class oe extends _.Container{constructor(e,t){super();this._lastAnimationFrame=-1,this.tilemap=e,this.z=t}clear(){let e=this.children;for(let t=0;t<e.length;t++)e[t].clear();this._previousLayers=0}cacheIfDirty(){let e=this.tilemap,t=this.children,i=this._previousLayers!==t.length;this._previousLayers=t.length;let r=this.canvasBuffer,s=this._tempRender;r||(r=this.canvasBuffer=document.createElement("canvas"),s=this._tempRender=new PIXI.CanvasRenderer({width:100,height:100,view:r}),s.context=s.rootContext,s.plugins.tilemap.dontUseTransform=!0),(r.width!==e._layerWidth||r.height!==e._layerHeight)&&(r.width=e._layerWidth,r.height=e._layerHeight,i=!0);let a;if(!i){for(a=0;a<t.length;a++)if(t[a].isModified(this._lastAnimationFrame!==e.animationFrame)){i=!0;break}}if(this._lastAnimationFrame=e.animationFrame,i)for(e._hackRenderer&&e._hackRenderer(s),s.context.clearRect(0,0,r.width,r.height),a=0;a<t.length;a++)t[a].clearModify(),t[a].renderCanvas(s);for(this.layerTransform=this.worldTransform,a=0;a<t.length;a++){this.layerTransform=t[a].worldTransform;break}}renderCanvas(e){this.cacheIfDirty();let t=this.layerTransform;e.context.setTransform(t.a,t.b,t.c,t.d,t.tx*e.resolution,t.ty*e.resolution);let i=this.tilemap;e.context.drawImage(this.canvasBuffer,0,0)}}const de={CanvasTileRenderer:k,CompositeRectTileLayer:re,Constant:m,GraphicsLayer:se,MultiTextureResource:U,RectTileLayer:L,TilemapShader:j,RectTileShader:G,RectTileGeom:V,TileRenderer:W,ZLayer:oe};c.CanvasTileRenderer=k,c.CompositeRectTileLayer=re,c.Constant=m,c.GraphicsLayer=se,c.MultiTextureResource=U,c.POINT_STRUCT_SIZE=M,c.RectTileGeom=V,c.RectTileLayer=L,c.RectTileShader=G,c.TileRenderer=W,c.TilemapShader=j,c.ZLayer=oe,c.fillSamplers=Y,c.generateFragmentSrc=ne,c.generateSampleSrc=ae,c.pixi_tilemap=de,Object.defineProperty(c,"__esModule",{value:!0})}),typeof pixi_tilemap!="undefined"&&Object.assign(this.PIXI.tilemap,pixi_tilemap);
//# sourceMappingURL=pixi-tilemap.umd.js.map
